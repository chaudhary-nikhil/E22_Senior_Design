<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live IMU 3D Visualization</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            padding-bottom: 40px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 300px;
            grid-template-rows: 40vh 1fr;
            gap: 15px;
            min-height: calc(100vh - 80px);
            padding-bottom: 30px;
        }
        
        .visualization {
            grid-row: 1 / 2;
            grid-column: 1 / 2;
            position: relative;
        }
        
        .charts {
            grid-row: 2 / 3;
            grid-column: 1 / 2;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            background: #2a2a2a;
            padding: 15px;
            padding-bottom: 10px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .chart-container {
            background: #333;
            padding: 12px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .chart-container h4 {
            margin: 0 0 10px 0;
            color: #fff;
            text-align: center;
            flex-shrink: 0;
        }
        
        .chart-wrapper {
            flex: 1;
            position: relative;
            min-height: 0;
        }
        
        .controls {
            grid-row: 1 / 3;
            grid-column: 2 / 3;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 10px;
            overflow-y: auto;
        }
        
        .metric {
            margin: 10px 0;
            padding: 8px;
            background: #333;
            border-radius: 5px;
            font-family: monospace;
        }

        .metric input[type="range"],
        .metric input[type="number"] {
            width: 100%;
            margin-top: 6px;
        }
        
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
        }
        
        .connected {
            background: #2d5a2d;
            color: #90ee90;
        }
        
        .disconnected {
            background: #5a2d2d;
            color: #ee9090;
        }
        
        button {
            width: 100%;
            background: #2f7dd1;
            color: white;
            border: 1px solid rgba(255,255,255,0.12);
            padding: 12px 14px;
            border-radius: 8px;
            cursor: pointer;
            margin: 6px 0;
            font-size: 14px;
            font-weight: 600;
            transition: transform 0.05s ease, background 0.15s ease, opacity 0.15s ease;
        }
        
        button:hover {
            background: #2468ad;
        }

        button:active {
            transform: translateY(1px);
        }
        
        button:disabled {
            background: #3f3f3f;
            opacity: 0.7;
            cursor: not-allowed;
        }
        
        #canvas {
            border: 1px solid #555;
            border-radius: 10px;
            width: 100%;
            height: 100%;
            display: block;
            background: #1a1a1a;
        }
        
        .visualization {
            background: #1a1a1a;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="visualization">
            <canvas id="canvas" width="800" height="400"></canvas>
        </div>
        
        <div class="charts">
            <div class="chart-container">
                <h4>Acceleration (m/s²)</h4>
                <div class="chart-wrapper">
                    <canvas id="accelChart"></canvas>
                </div>
            </div>
            <div class="chart-container">
                <h4>Angular Velocity (rad/s)</h4>
                <div class="chart-wrapper">
                    <canvas id="gyroChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <h3>Live IMU Data</h3>
            
            <div id="status" class="status disconnected">
                Disconnected
            </div>
            
            <div class="metric">
                <strong>Acceleration (m/s²)</strong><br>
                X: <span id="ax">0.000</span><br>
                Y: <span id="ay">0.000</span><br>
                Z: <span id="az">0.000</span>
            </div>
            
            <div class="metric">
                <strong>Angular Velocity (rad/s)</strong><br>
                X: <span id="gx">0.000</span><br>
                Y: <span id="gy">0.000</span><br>
                Z: <span id="gz">0.000</span>
            </div>
            
            <div class="metric">
                <strong>Position (m)</strong><br>
                X: <span id="px">0.000</span><br>
                Y: <span id="py">0.000</span><br>
                Z: <span id="pz">0.000</span>
            </div>
            
            <div class="metric">
                <strong>Quaternion</strong><br>
                W: <span id="qw">1.000</span><br>
                X: <span id="qx">0.000</span><br>
                Y: <span id="qy">0.000</span><br>
                Z: <span id="qz">0.000</span>
            </div>

            <div class="metric">
                <strong>Visualizer Position Scale</strong><br>
                <input 
                    type="range" 
                    id="scaleSlider" 
                    min="0.1" 
                    max="10" 
                    step="0.1" 
                    value="5"
                    oninput="updateScale(this.value)">
                <input 
                    type="number" 
                    id="scaleInput"
                    min="0.1"
                    max="10"
                    step="0.1"
                    value="5"
                    oninput="updateScale(this.value)">
                <div>Current scale: <span id="scaleValue">5.0×</span></div>
            </div>
            
            <div class="metric">
                <strong>Session Time</strong><br>
                <span id="timestamp" style="font-size: 1.3em; font-family: 'Courier New', monospace;">00:00</span>
            </div>

            <div class="metric">
                <strong>Calibration (0=Bad, 3=Good)</strong><br>
                System: <span id="cal-sys">0</span><br>
                Gyro:   <span id="cal-gyro">0</span><br>
                Accel:  <span id="cal-accel">0</span><br>
                Mag:    <span id="cal-mag">0</span>
            </div>
            
            <div class="status disconnected" id="tracking-status">
                Tracking: Inactive
            </div>
            
            <div class="metric">
                <strong>Stroke Count</strong><br>
                <span id="stroke-count" style="font-size: 1.8em; font-weight: bold;">0</span>
            </div>
            
            <!-- Stroke Analysis Panel -->
            <div class="metric" style="background: linear-gradient(135deg, #1e3a5f 0%, #2d4a6f 100%); border: 1px solid #3d6a9f;">
                <strong style="color: #7eb8ff;">Stroke Analysis</strong>
                <div style="margin-top: 8px; font-size: 0.9em;">
                    <div style="display: flex; justify-content: space-between; margin: 4px 0;">
                        <span>Last Stroke:</span>
                        <span id="last-stroke-time" style="color: #4fc3f7;">--</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin: 4px 0;">
                        <span>Stroke Length:</span>
                        <span id="stroke-length" style="color: #81c784;">--</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin: 4px 0;">
                        <span>Avg Rate:</span>
                        <span id="stroke-rate" style="color: #ffb74d;">--</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin: 4px 0;">
                        <span>Consistency:</span>
                        <span id="stroke-consistency" style="color: #ce93d8;">--</span>
                    </div>
                </div>
            </div>
            
            <!-- Stroke Comparison Controls -->
            <div class="metric" style="background: #2d3a2d; border: 1px solid #4a5a4a;">
                <strong style="color: #a5d6a7;">Comparison View</strong>
                <div style="margin-top: 8px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="overlay-strokes" onchange="toggleStrokeOverlay()" checked>
                        <span style="font-size: 0.9em;">Overlay past strokes</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-top: 6px;">
                        <input type="checkbox" id="show-water-plane" onchange="toggleWaterPlane()">
                        <span style="font-size: 0.9em;">Show water reference</span>
                    </label>
                    <div style="margin-top: 8px; font-size: 0.85em; color: #888;">
                        Strokes shown: <span id="strokes-displayed">0</span>/10
                    </div>
                </div>
            </div>
            
            <button id="btn-connect" onclick="connect()">Connect</button>
            <button id="btn-disconnect" onclick="disconnect()">Disconnect</button>
            <button id="btn-reset-view" onclick="resetView()">Reset View</button>
            <button id="btn-clear-strokes" onclick="clearStrokes()">Clear Strokes</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, imuCube, trail = [];
        let controls = null;
        let positionLine = null;     // Line from origin to cube (shows current position)
        let liveTrailLine = null;    // Live trail showing current stroke path
        let eventSource = null;
        let isConnected = false;
        let positionScale = 5.0; // default: up close / visible trail
        let strokeTrails = []; // Array of completed stroke trail objects
        let currentStrokePoints = []; // Points for current stroke (Vector3 array)
        let currentStrokeAccelMags = []; // Acceleration magnitudes for phase coloring
        let lastStrokeCount = 0;
        let initialQuaternion = null; // Store initial orientation when calibrated
        let isCalibrated = false;
        let resetPending = false; // Flag to handle async reset
        const DEBUG_LOG_STREAM = false;
        
        // Stroke analysis data
        let strokeHistory = []; // Array of {points, accelMags, startTime, endTime, length, duration}
        let strokeStartTime = null; // When current stroke started
        let waterPlane = null; // Reference water plane mesh
        let showOverlay = true; // Whether to show past strokes
        const MAX_STROKES_DISPLAYED = 10; // Maximum strokes to keep for comparison
        const MIN_STROKE_POINTS = 10; // Minimum points to consider a valid stroke (filters noise)
        
        // Session timer variables
        let sessionStartTime = null;
        let sessionTimerInterval = null;
        
        function formatSessionTime(totalSeconds) {
            const mins = Math.floor(totalSeconds / 60);
            const secs = Math.floor(totalSeconds % 60);
            return String(mins).padStart(2, '0') + ':' + String(secs).padStart(2, '0');
        }
        
        function updateSessionTimer() {
            if (sessionStartTime === null) return;
            const elapsed = (Date.now() - sessionStartTime) / 1000;
            document.getElementById('timestamp').textContent = formatSessionTime(elapsed);
        }
        
        function startSessionTimer() {
            if (sessionStartTime === null) {
                sessionStartTime = Date.now();
            }
            if (sessionTimerInterval === null) {
                sessionTimerInterval = setInterval(updateSessionTimer, 100);
            }
        }
        
        function stopSessionTimer() {
            if (sessionTimerInterval !== null) {
                clearInterval(sessionTimerInterval);
                sessionTimerInterval = null;
            }
        }
        
        function resetSessionTimer() {
            stopSessionTimer();
            sessionStartTime = null;
            document.getElementById('timestamp').textContent = '00:00';
        }
        
        // Chart variables
        let accelChart, gyroChart;
        const maxDataPoints = 50;
        let timeLabels = [];
        let accelData = { x: [], y: [], z: [] };
        let gyroData = { x: [], y: [], z: [] };
        
        // Smoothing filter (exponential moving average)
        const smoothingFactor = 0.3; // 0 = no smoothing, 1 = max smoothing
        let lastAccel = { x: 0, y: 0, z: 0 };
        let lastGyro = { x: 0, y: 0, z: 0 };
        
        // Initialize 3D scene
        function initScene() {
            try {
                const canvas = document.getElementById('canvas');
                if (!canvas) {
                    console.error('Canvas element not found!');
                    return;
                }
                
                if (typeof THREE === 'undefined') {
                    console.error('Three.js library not loaded!');
                    return;
                }
                
                console.log('Initializing 3D scene...');
                
                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x1a1a1a);
                
                // Camera
                camera = new THREE.PerspectiveCamera(75, canvas.width / canvas.height, 0.1, 1000);
                camera.position.set(3, 3, 3);
                camera.lookAt(0, 0, 0);
                
                // Check WebGL support
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) {
                    console.error('WebGL is not supported in this browser!');
                    canvas.style.background = '#5a2d2d';
                    canvas.style.display = 'flex';
                    canvas.style.alignItems = 'center';
                    canvas.style.justifyContent = 'center';
                    canvas.style.color = '#fff';
                    canvas.style.fontSize = '18px';
                    canvas.textContent = 'WebGL not supported. Please enable hardware acceleration in your browser settings.';
                    return;
                }
                
                // Renderer - use actual canvas display size
                try {
                    renderer = new THREE.WebGLRenderer({ 
                        canvas: canvas, 
                        antialias: true,
                        powerPreference: "high-performance"
                    });
                } catch (e) {
                    console.error('Failed to create WebGL renderer:', e);
                    canvas.style.background = '#5a2d2d';
                    canvas.style.display = 'flex';
                    canvas.style.alignItems = 'center';
                    canvas.style.justifyContent = 'center';
                    canvas.style.color = '#fff';
                    canvas.style.fontSize = '18px';
                    canvas.textContent = 'Failed to initialize WebGL renderer.';
                    return;
                }
                
                const rect = canvas.getBoundingClientRect();
                if (rect.width > 0 && rect.height > 0) {
                    renderer.setSize(rect.width, rect.height);
                    camera.aspect = rect.width / rect.height;
                    camera.updateProjectionMatrix();
                } else {
                    // Fallback to canvas dimensions
                    renderer.setSize(canvas.width, canvas.height);
                    camera.aspect = canvas.width / canvas.height;
                    camera.updateProjectionMatrix();
                }
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                console.log('Renderer initialized with size:', renderer.domElement.width, 'x', renderer.domElement.height);

                // Controls (mouse/touch orbit) so "Reset View" actually matters
                if (THREE.OrbitControls) {
                    controls = new THREE.OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = true;
                    controls.dampingFactor = 0.08;
                    controls.target.set(0, 0, 0);
                    controls.update();
                    controls.saveState(); // default "Reset View" state
                } else {
                    console.warn('OrbitControls not available; Reset View will only re-position camera.');
                }
                
                // Add grid
                const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
                scene.add(gridHelper);
                
                // Add axes
                const axesHelper = new THREE.AxesHelper(2);
                scene.add(axesHelper);
                
                // Create IMU cube - size appropriate for hand visualization
                // At 5x scale, 0.3 units = ~6cm in real space (reasonable for hand-mounted sensor)
                const geometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const material = new THREE.MeshLambertMaterial({ color: 0xff4444 });
                imuCube = new THREE.Mesh(geometry, material);
                imuCube.position.set(0, 0, 0);
                imuCube.castShadow = true;
                scene.add(imuCube);
                
                // Add position indicator line (from origin to cube) - helps see movement
                const posLineGeom = new THREE.BufferGeometry();
                posLineGeom.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0, 0,0,0], 3));
                positionLine = new THREE.Line(posLineGeom, new THREE.LineBasicMaterial({ 
                    color: 0x00ff00, 
                    linewidth: 2,
                    opacity: 0.6,
                    transparent: true
                }));
                scene.add(positionLine);
                
                // Live trail line (shows current stroke path in real-time)
                const liveTrailGeom = new THREE.BufferGeometry();
                liveTrailGeom.setAttribute('position', new THREE.Float32BufferAttribute([], 3));
                liveTrailLine = new THREE.Line(liveTrailGeom, new THREE.LineBasicMaterial({
                    color: 0xffff00,
                    linewidth: 3,
                    opacity: 0.9,
                    transparent: true
                }));
                scene.add(liveTrailLine);
                
                console.log('IMU cube and indicators added to scene');
                
                // Create water reference plane (horizontal, semi-transparent blue)
                const waterGeom = new THREE.PlaneGeometry(4, 4);
                const waterMat = new THREE.MeshBasicMaterial({
                    color: 0x1e88e5,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.DoubleSide
                });
                waterPlane = new THREE.Mesh(waterGeom, waterMat);
                waterPlane.rotation.x = -Math.PI / 2; // Make horizontal
                waterPlane.position.y = 0; // At origin height
                waterPlane.visible = false; // Hidden by default
                scene.add(waterPlane);
                
                // Add grid on water plane for depth reference
                const waterGrid = new THREE.GridHelper(4, 20, 0x2196f3, 0x1565c0);
                waterGrid.position.y = 0.01;
                waterGrid.visible = false;
                waterGrid.name = 'waterGrid';
                scene.add(waterGrid);
                
                // Add lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 5, 5);
                directionalLight.castShadow = true;
                scene.add(directionalLight);
                
                // Start render loop
                animate();
                console.log('3D scene initialized successfully');
            } catch (error) {
                console.error('Error initializing 3D scene:', error);
            }
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            if (renderer && scene && camera) {
                if (controls) controls.update();
                renderer.render(scene, camera);
            }
        }
        
        // Initialize charts
        function initCharts() {
            const commonOptions = {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                scales: {
                    x: {
                        ticks: { 
                            color: '#fff',
                            maxRotation: 45,
                            minRotation: 45,
                            autoSkip: true,
                            maxTicksLimit: 10
                        },
                        grid: { color: '#444' }
                    },
                    y: {
                        ticks: { 
                            color: '#fff'
                        },
                        grid: { color: '#444' }
                    }
                },
                plugins: {
                    legend: {
                        labels: { color: '#fff' }
                    }
                },
                layout: {
                    padding: {
                        bottom: 10
                    }
                }
            };
            
            // Acceleration chart with fixed Y-axis
            const accelCtx = document.getElementById('accelChart').getContext('2d');
            accelChart = new Chart(accelCtx, {
                type: 'line',
                data: {
                    labels: timeLabels,
                    datasets: [
                        {
                            label: 'X',
                            data: accelData.x,
                            borderColor: 'rgb(255, 99, 132)',
                            backgroundColor: 'rgba(255, 99, 132, 0.1)',
                            tension: 0.4,
                            pointRadius: 0,
                            borderWidth: 2
                        },
                        {
                            label: 'Y',
                            data: accelData.y,
                            borderColor: 'rgb(54, 162, 235)',
                            backgroundColor: 'rgba(54, 162, 235, 0.1)',
                            tension: 0.4,
                            pointRadius: 0,
                            borderWidth: 2
                        },
                        {
                            label: 'Z',
                            data: accelData.z,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.1)',
                            tension: 0.4,
                            pointRadius: 0,
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            min: -2,
                            max: 12,
                            ticks: {
                                color: '#fff',
                                stepSize: 2
                            }
                        }
                    }
                }
            });
            
            // Gyroscope chart with fixed Y-axis
            const gyroCtx = document.getElementById('gyroChart').getContext('2d');
            gyroChart = new Chart(gyroCtx, {
                type: 'line',
                data: {
                    labels: timeLabels,
                    datasets: [
                        {
                            label: 'X',
                            data: gyroData.x,
                            borderColor: 'rgb(255, 159, 64)',
                            backgroundColor: 'rgba(255, 159, 64, 0.1)',
                            tension: 0.4,
                            pointRadius: 0,
                            borderWidth: 2
                        },
                        {
                            label: 'Y',
                            data: gyroData.y,
                            borderColor: 'rgb(153, 102, 255)',
                            backgroundColor: 'rgba(153, 102, 255, 0.1)',
                            tension: 0.4,
                            pointRadius: 0,
                            borderWidth: 2
                        },
                        {
                            label: 'Z',
                            data: gyroData.z,
                            borderColor: 'rgb(201, 203, 207)',
                            backgroundColor: 'rgba(201, 203, 207, 0.1)',
                            tension: 0.4,
                            pointRadius: 0,
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            min: -1,
                            max: 1,
                            ticks: {
                                color: '#fff',
                                stepSize: 0.25
                            }
                        }
                    }
                }
            });
        }
        
        // Apply exponential smoothing filter
        function smoothData(newValue, lastValue, factor) {
            return lastValue + factor * (newValue - lastValue);
        }
        
        // Connect to Server-Sent Events
        function connect() {
            if (eventSource) {
                eventSource.close();
            }
            
            // Use relative URL so it works on any port / host
            eventSource = new EventSource('/events');
            
            eventSource.onopen = function() {
                isConnected = true;
                updateStatus('Connected', true);
                startSessionTimer();  // Start session timer on connect
                updateButtonStates();
                console.log('Connected to ESP32');
            };
            
            eventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    updateDisplay(data);
                    updateIMUVisualization(data);
                    if (DEBUG_LOG_STREAM) console.log('Received data:', data);
                } catch (e) {
                    console.error('Error parsing data:', e);
                }
            };
            
            eventSource.onerror = function(error) {
                console.error('SSE error:', error);
                isConnected = false;
                updateStatus('Error', false);
                updateButtonStates();
            };
        }
        
        // Disconnect from Server-Sent Events
        function disconnect() {
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }
            isConnected = false;
            updateStatus('Disconnected', false);
            updateButtonStates();
            stopSessionTimer();
        }

        function updateButtonStates() {
            const btnConnect = document.getElementById('btn-connect');
            const btnDisconnect = document.getElementById('btn-disconnect');
            if (!btnConnect || !btnDisconnect) return;

            btnConnect.disabled = isConnected;
            btnDisconnect.disabled = !isConnected;
        }
        
        // Update status display
        function updateStatus(message, connected) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = connected ? 'status connected' : 'status disconnected';
        }
        
        // Update data display
        function updateDisplay(data) {
            // Acceleration
            document.getElementById('ax').textContent = data.acceleration.ax.toFixed(3);
            document.getElementById('ay').textContent = data.acceleration.ay.toFixed(3);
            document.getElementById('az').textContent = data.acceleration.az.toFixed(3);
            
            // Angular velocity
            document.getElementById('gx').textContent = data.angular_velocity.gx.toFixed(3);
            document.getElementById('gy').textContent = data.angular_velocity.gy.toFixed(3);
            document.getElementById('gz').textContent = data.angular_velocity.gz.toFixed(3);
            
            // Position
            document.getElementById('px').textContent = data.position.px.toFixed(3);
            document.getElementById('py').textContent = data.position.py.toFixed(3);
            document.getElementById('pz').textContent = data.position.pz.toFixed(3);
            
            // Quaternion
            document.getElementById('qw').textContent = data.quaternion.qw.toFixed(3);
            document.getElementById('qx').textContent = data.quaternion.qx.toFixed(3);
            document.getElementById('qy').textContent = data.quaternion.qy.toFixed(3);
            document.getElementById('qz').textContent = data.quaternion.qz.toFixed(3);
            
            // Session time is updated by the timer, not from data stream

            // Calibration Status
            if (data.calibration) {
                let sys = data.calibration.sys;
                let accel = data.calibration.accel;
                let gyro = data.calibration.gyro;
                
                document.getElementById('cal-sys').textContent = sys;
                document.getElementById('cal-gyro').textContent = gyro;
                document.getElementById('cal-accel').textContent = accel;
                document.getElementById('cal-mag').textContent = data.calibration.mag;

                // Tracking Status
                const trackingStatus = document.getElementById('tracking-status');
                if (data.tracking_active) {
                    trackingStatus.textContent = "Tracking: ACTIVE (Moving)";
                    trackingStatus.className = "status connected";
                } else {
                    // Determine WHY it's inactive
                    if (accel < 2 || gyro < 2) {
                        trackingStatus.textContent = "Tracking: PAUSED (Need Calib: Accel/Gyro >= 2)";
                        trackingStatus.className = "status disconnected";
                    } else {
                        trackingStatus.textContent = "Tracking: READY (Move to Start)";
                        trackingStatus.className = "status" // Neutral/Grey
                        trackingStatus.style.backgroundColor = "#666";
                        trackingStatus.style.color = "#fff";
                    }
                }
            }
        }
        
        // Update 3D visualization
        function updateIMUVisualization(data) {
            // Check if we just became calibrated - set reference orientation
            const cal = data.calibration;
            const nowCalibrated = (cal.accel >= 2 && cal.gyro >= 2);
            if (nowCalibrated && !isCalibrated) {
                // Just calibrated - store initial quaternion as reference
                // This makes the cube start "straight" relative to when it was calibrated
                initialQuaternion = new THREE.Quaternion(
                    data.quaternion.qx,
                    data.quaternion.qy,
                    data.quaternion.qz,
                    data.quaternion.qw
                ).inverse(); // Store inverse so we can "subtract" it later
                isCalibrated = true;
            }
            
            // =================================================================
            // POSITION MAPPING (Python world-frame → Three.js scene)
            // =================================================================
            // Python: position[0]=X (left/right), position[1]=Y (forward), position[2]=Z (up/down)
            // Three.js: X=left/right, Y=up/down, Z=forward/back
            // Mapping: Three.js X = -px, Three.js Y = pz (vertical), Three.js Z = py
            const scaledX = -data.position.px * positionScale;
            const scaledY = data.position.pz * positionScale;   // Vertical (up/down)
            const scaledZ = data.position.py * positionScale;   // Forward/back
            
            imuCube.position.set(scaledX, scaledY, scaledZ);
            
            // Update position indicator line (green line from origin to cube)
            if (positionLine) {
                const positions = positionLine.geometry.attributes.position.array;
                positions[3] = scaledX;
                positions[4] = scaledY;
                positions[5] = scaledZ;
                positionLine.geometry.attributes.position.needsUpdate = true;
            }
            
            // Update rotation using quaternion
            let quaternion = new THREE.Quaternion(
                data.quaternion.qx,
                data.quaternion.qy,
                data.quaternion.qz,
                data.quaternion.qw
            );
            
            // Apply reference orientation so cube starts "straight" when calibrated
            if (initialQuaternion) {
                quaternion = quaternion.multiply(initialQuaternion);
            }
            
            imuCube.setRotationFromQuaternion(quaternion);
            
            // =================================================================
            // STROKE VISUALIZATION (Research-backed swimming analysis)
            // =================================================================
            const strokeCount = data.stroke_count || 0;
            const isTracking = data.tracking_active || false;
            const accelMag = data.stroke_debug ? data.stroke_debug.accel_mag : 0;
            
            // Change cube color based on tracking state (visual feedback)
            // Red = idle, Green = tracking (capturing position data)
            if (imuCube && imuCube.material) {
                imuCube.material.color.setHex(isTracking ? 0x44ff44 : 0xff4444);
            }
            
            // Handle reset synchronization
            if (resetPending) {
                if (strokeCount === 0) {
                    resetPending = false;
                    lastStrokeCount = 0;
                }
                document.getElementById('stroke-count').textContent = '0';
            } else {
                document.getElementById('stroke-count').textContent = strokeCount;
            }
            
            // Track stroke start time for duration calculation
            if (isTracking && strokeStartTime === null) {
                strokeStartTime = Date.now();
            }
            
            // If new stroke detected, save previous stroke with metrics
            if (!resetPending && strokeCount > lastStrokeCount) {
                // Only save if we have enough points (filters noise/false positives)
                if (currentStrokePoints.length >= MIN_STROKE_POINTS) {
                    const strokeData = saveStrokeWithMetrics(
                        currentStrokePoints, 
                        currentStrokeAccelMags,
                        strokeStartTime,
                        strokeCount - 1
                    );
                    updateStrokeAnalysisPanel(strokeData);
                }
                // Reset for new stroke
                currentStrokePoints = [];
                currentStrokeAccelMags = [];
                strokeStartTime = null;
                lastStrokeCount = strokeCount;
            }
            
            // Add point to current stroke if tracking is active
            if (isTracking) {
                currentStrokePoints.push(new THREE.Vector3(scaledX, scaledY, scaledZ));
                currentStrokeAccelMags.push(accelMag);
                
                // Limit current stroke points to prevent memory issues
                if (currentStrokePoints.length > 500) {
                    currentStrokePoints.shift();
                    currentStrokeAccelMags.shift();
                }
            } else {
                // Not tracking - reset stroke start time
                if (currentStrokePoints.length < MIN_STROKE_POINTS) {
                    // Discard incomplete stroke data
                    currentStrokePoints = [];
                    currentStrokeAccelMags = [];
                }
                strokeStartTime = null;
            }
            
            // Update live trail line (yellow line showing current stroke in real-time)
            if (liveTrailLine && currentStrokePoints.length > 0) {
                const flatPositions = [];
                for (const pt of currentStrokePoints) {
                    flatPositions.push(pt.x, pt.y, pt.z);
                }
                liveTrailLine.geometry.setAttribute('position', 
                    new THREE.Float32BufferAttribute(flatPositions, 3));
                liveTrailLine.geometry.attributes.position.needsUpdate = true;
            } else if (liveTrailLine && currentStrokePoints.length === 0) {
                // Clear live trail when not tracking
                liveTrailLine.geometry.setAttribute('position', 
                    new THREE.Float32BufferAttribute([], 3));
            }
            
            // Update charts
            updateCharts(data);
        }
        
        // Save stroke with full metrics and create visualization
        function saveStrokeWithMetrics(points, accelMags, startTime, strokeIndex) {
            if (points.length < 2) return null;
            
            const endTime = Date.now();
            const duration = startTime ? (endTime - startTime) / 1000 : 0;
            
            // Calculate stroke path length (sum of distances between consecutive points)
            let pathLength = 0;
            for (let i = 1; i < points.length; i++) {
                pathLength += points[i].distanceTo(points[i-1]);
            }
            // Convert from scaled units back to approximate meters
            pathLength = pathLength / positionScale;
            
            // Calculate stroke bounding box for analysis
            const minPt = new THREE.Vector3(Infinity, Infinity, Infinity);
            const maxPt = new THREE.Vector3(-Infinity, -Infinity, -Infinity);
            for (const pt of points) {
                minPt.min(pt);
                maxPt.max(pt);
            }
            const strokeExtent = maxPt.clone().sub(minPt);
            
            // Store stroke data
            const strokeData = {
                points: points.slice(), // Copy points
                accelMags: accelMags.slice(),
                startTime: startTime,
                endTime: endTime,
                duration: duration,
                pathLength: pathLength,
                extent: strokeExtent,
                index: strokeIndex
            };
            strokeHistory.push(strokeData);
            
            // Create phase-colored trail visualization
            createPhaseColoredTrail(strokeData);
            
            // Keep only last MAX_STROKES_DISPLAYED
            if (strokeHistory.length > MAX_STROKES_DISPLAYED) {
                strokeHistory.shift();
                // Remove oldest trail from scene
                if (strokeTrails.length > MAX_STROKES_DISPLAYED) {
                    const oldTrail = strokeTrails.shift();
                    scene.remove(oldTrail);
                    if (oldTrail.geometry) oldTrail.geometry.dispose();
                    if (oldTrail.material) {
                        if (Array.isArray(oldTrail.material)) {
                            oldTrail.material.forEach(m => m.dispose());
                        } else {
                            oldTrail.material.dispose();
                        }
                    }
                }
            }
            
            document.getElementById('strokes-displayed').textContent = strokeTrails.length;
            return strokeData;
        }
        
        // Create a phase-colored trail (color based on acceleration magnitude)
        // Research: High accel = catch/pull phase (blue), Low accel = recovery (green)
        function createPhaseColoredTrail(strokeData) {
            if (!strokeData || strokeData.points.length < 2) return;
            
            const points = strokeData.points;
            const accelMags = strokeData.accelMags;
            
            // Find min/max acceleration for normalization
            let minAccel = Infinity, maxAccel = -Infinity;
            for (const a of accelMags) {
                if (a < minAccel) minAccel = a;
                if (a > maxAccel) maxAccel = a;
            }
            const accelRange = Math.max(maxAccel - minAccel, 0.1);
            
            // Create geometry with vertex colors
            const positions = [];
            const colors = [];
            
            for (let i = 0; i < points.length; i++) {
                positions.push(points[i].x, points[i].y, points[i].z);
                
                // Map acceleration to color
                // Low accel (recovery) = cyan/green, High accel (power phase) = orange/red
                const normalizedAccel = (accelMags[i] - minAccel) / accelRange;
                const color = new THREE.Color();
                
                if (normalizedAccel < 0.3) {
                    // Recovery phase - cyan
                    color.setHSL(0.5, 0.8, 0.5);
                } else if (normalizedAccel < 0.6) {
                    // Transition - yellow/green
                    color.setHSL(0.15, 0.8, 0.5);
                } else {
                    // Power/catch phase - orange/red
                    color.setHSL(0.05, 0.9, 0.55);
                }
                
                colors.push(color.r, color.g, color.b);
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.LineBasicMaterial({
                vertexColors: true,
                linewidth: 2,
                opacity: showOverlay ? 0.7 : 0,
                transparent: true
            });
            
            const line = new THREE.Line(geometry, material);
            line.visible = showOverlay;
            scene.add(line);
            strokeTrails.push(line);
        }
        
        // Update the stroke analysis panel with metrics
        function updateStrokeAnalysisPanel(strokeData) {
            if (!strokeData) return;
            
            // Last stroke duration
            const durationStr = strokeData.duration.toFixed(2) + 's';
            document.getElementById('last-stroke-time').textContent = durationStr;
            
            // Stroke path length (approximate)
            const lengthStr = strokeData.pathLength.toFixed(2) + 'm';
            document.getElementById('stroke-length').textContent = lengthStr;
            
            // Calculate stroke rate (strokes per minute) from recent strokes
            if (strokeHistory.length >= 2) {
                const recentStrokes = strokeHistory.slice(-5);
                let totalDuration = 0;
                for (let i = 1; i < recentStrokes.length; i++) {
                    const timeBetween = (recentStrokes[i].startTime - recentStrokes[i-1].endTime) / 1000;
                    totalDuration += recentStrokes[i].duration + Math.max(0, timeBetween);
                }
                const avgStrokeTime = totalDuration / (recentStrokes.length - 1);
                const strokesPerMin = avgStrokeTime > 0 ? (60 / avgStrokeTime).toFixed(1) : '--';
                document.getElementById('stroke-rate').textContent = strokesPerMin + '/min';
            }
            
            // Calculate consistency (standard deviation of stroke lengths)
            if (strokeHistory.length >= 3) {
                const lengths = strokeHistory.slice(-5).map(s => s.pathLength);
                const avgLength = lengths.reduce((a, b) => a + b, 0) / lengths.length;
                const variance = lengths.reduce((sum, l) => sum + Math.pow(l - avgLength, 2), 0) / lengths.length;
                const stdDev = Math.sqrt(variance);
                const consistency = Math.max(0, 100 - (stdDev / avgLength) * 100);
                
                let consistencyStr = consistency.toFixed(0) + '%';
                if (consistency >= 90) consistencyStr += ' ⭐';
                else if (consistency >= 75) consistencyStr += ' ✓';
                document.getElementById('stroke-consistency').textContent = consistencyStr;
            } else {
                document.getElementById('stroke-consistency').textContent = 'Need 3+ strokes';
            }
        }
        
        // Toggle stroke overlay visibility
        function toggleStrokeOverlay() {
            showOverlay = document.getElementById('overlay-strokes').checked;
            strokeTrails.forEach(trail => {
                if (trail.material) {
                    trail.material.opacity = showOverlay ? 0.7 : 0;
                    trail.visible = showOverlay;
                }
            });
        }
        
        // Toggle water reference plane
        function toggleWaterPlane() {
            const show = document.getElementById('show-water-plane').checked;
            if (waterPlane) waterPlane.visible = show;
            const grid = scene.getObjectByName('waterGrid');
            if (grid) grid.visible = show;
        }
        
        // Update charts with new data and smoothing
        function updateCharts(data) {
            const timeLabel = new Date(data.timestamp).toLocaleTimeString();
            
            // Apply smoothing to raw data
            lastAccel.x = smoothData(data.acceleration.ax, lastAccel.x, smoothingFactor);
            lastAccel.y = smoothData(data.acceleration.ay, lastAccel.y, smoothingFactor);
            lastAccel.z = smoothData(data.acceleration.az, lastAccel.z, smoothingFactor);
            
            lastGyro.x = smoothData(data.angular_velocity.gx, lastGyro.x, smoothingFactor);
            lastGyro.y = smoothData(data.angular_velocity.gy, lastGyro.y, smoothingFactor);
            lastGyro.z = smoothData(data.angular_velocity.gz, lastGyro.z, smoothingFactor);
            
            // Add smoothed data points
            timeLabels.push(timeLabel);
            accelData.x.push(lastAccel.x);
            accelData.y.push(lastAccel.y);
            accelData.z.push(lastAccel.z);
            gyroData.x.push(lastGyro.x);
            gyroData.y.push(lastGyro.y);
            gyroData.z.push(lastGyro.z);
            
            // Keep only the last maxDataPoints
            if (timeLabels.length > maxDataPoints) {
                timeLabels.shift();
                accelData.x.shift();
                accelData.y.shift();
                accelData.z.shift();
                gyroData.x.shift();
                gyroData.y.shift();
                gyroData.z.shift();
            }
            
            // Update charts
            accelChart.update('none');
            gyroChart.update('none');
        }
        
        // Reset camera view
        function resetView() {
            if (!camera) return;
            // Reset scaling to a close, readable default
            updateScale(5.0);
            if (controls) {
                controls.reset();
                controls.update();
                return;
            }
            // Fallback if controls aren't available
            camera.position.set(3, 3, 3);
            camera.lookAt(0, 0, 0);
        }
        
        // Clear all stroke trails and reset count
        function clearStrokes() {
            // Safe to call even if scene isn't ready yet
            if (!scene) {
                strokeTrails = [];
                strokeHistory = [];
                currentStrokePoints = [];
                currentStrokeAccelMags = [];
                lastStrokeCount = 0;
                strokeStartTime = null;
                resetPending = true;
                document.getElementById('stroke-count').textContent = '0';
                resetAnalysisPanel();
                fetch('/reset', { method: 'POST' })
                    .catch(err => {
                        console.log('Reset request failed:', err);
                        resetPending = false;
                    });
                return;
            }
            
            // Remove completed stroke trails
            strokeTrails.forEach(trail => {
                scene.remove(trail);
                if (trail.geometry) trail.geometry.dispose();
                if (trail.material) {
                    if (Array.isArray(trail.material)) {
                        trail.material.forEach(m => m.dispose());
                    } else {
                        trail.material.dispose();
                    }
                }
            });
            strokeTrails = [];
            strokeHistory = [];
            currentStrokePoints = [];
            currentStrokeAccelMags = [];
            lastStrokeCount = 0;
            strokeStartTime = null;
            
            // Clear live trail line
            if (liveTrailLine) {
                liveTrailLine.geometry.setAttribute('position', 
                    new THREE.Float32BufferAttribute([], 3));
            }
            
            // Reset cube position to origin
            if (imuCube) {
                imuCube.position.set(0, 0, 0);
            }
            
            // Reset position indicator line
            if (positionLine) {
                const positions = positionLine.geometry.attributes.position.array;
                positions[3] = 0;
                positions[4] = 0;
                positions[5] = 0;
                positionLine.geometry.attributes.position.needsUpdate = true;
            }
            
            // Reset stroke count and analysis panel
            document.getElementById('stroke-count').textContent = '0';
            resetAnalysisPanel();
            
            // Reset session timer and restart if connected
            resetSessionTimer();
            if (isConnected) {
                startSessionTimer();
            }
            
            // Set flag to ignore incoming stroke counts until server confirms reset
            resetPending = true;
            
            // Send reset request to server
            fetch('/reset', { method: 'POST' })
                .then(response => {
                    if (response.ok) console.log('Reset confirmed by server');
                })
                .catch(err => {
                    console.log('Reset request failed:', err);
                    resetPending = false;
                });
        }
        
        // Reset the stroke analysis panel to default values
        function resetAnalysisPanel() {
            document.getElementById('last-stroke-time').textContent = '--';
            document.getElementById('stroke-length').textContent = '--';
            document.getElementById('stroke-rate').textContent = '--';
            document.getElementById('stroke-consistency').textContent = '--';
            document.getElementById('strokes-displayed').textContent = '0';
        }

        function updateScale(value) {
            const numeric = Math.max(0.1, Math.min(10, parseFloat(value) || 1));
            positionScale = numeric;
            document.getElementById('scaleSlider').value = numeric;
            document.getElementById('scaleInput').value = numeric.toFixed(1);
            document.getElementById('scaleValue').textContent = numeric.toFixed(1) + '×';
        }
        
        // Initialize when page loads
        window.addEventListener('load', function() {
            // Delay scene initialization to ensure canvas is fully rendered
            setTimeout(function() {
                initScene();
                initCharts();
            }, 100);
            // Default zoom: make trails visible immediately
            updateScale(5.0);
            updateButtonStates();
            // Auto-connect
            setTimeout(connect, 1000);
        });
        
        // Handle window resize
        window.addEventListener('resize', function() {
            if (!renderer || !camera) return;
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            if (rect.width > 0 && rect.height > 0) {
                camera.aspect = rect.width / rect.height;
                camera.updateProjectionMatrix();
                renderer.setSize(rect.width, rect.height);
            }
        });
    </script>
</body>
</html>
