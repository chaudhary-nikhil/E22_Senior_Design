<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live IMU 3D Visualization</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            padding-bottom: 40px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 300px;
            grid-template-rows: 40vh 1fr;
            gap: 15px;
            min-height: calc(100vh - 80px);
            padding-bottom: 30px;
        }
        
        .visualization {
            grid-row: 1 / 2;
            grid-column: 1 / 2;
            position: relative;
        }
        
        .charts {
            grid-row: 2 / 3;
            grid-column: 1 / 2;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            background: #2a2a2a;
            padding: 15px;
            padding-bottom: 10px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .chart-container {
            background: #333;
            padding: 12px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .chart-container h4 {
            margin: 0 0 10px 0;
            color: #fff;
            text-align: center;
            flex-shrink: 0;
        }
        
        .chart-wrapper {
            flex: 1;
            position: relative;
            min-height: 0;
        }
        
        .controls {
            grid-row: 1 / 3;
            grid-column: 2 / 3;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 10px;
            overflow-y: auto;
        }
        
        .metric {
            margin: 10px 0;
            padding: 8px;
            background: #333;
            border-radius: 5px;
            font-family: monospace;
        }
        
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
        }
        
        .connected {
            background: #2d5a2d;
            color: #90ee90;
        }
        
        .disconnected {
            background: #5a2d2d;
            color: #ee9090;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        #canvas {
            border: 1px solid #555;
            border-radius: 10px;
            width: 100%;
            height: 100%;
            display: block;
            background: #1a1a1a;
        }
        
        .visualization {
            background: #1a1a1a;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="visualization">
            <canvas id="canvas" width="800" height="400"></canvas>
        </div>
        
        <div class="charts">
            <div class="chart-container">
                <h4>Acceleration (m/s²)</h4>
                <div class="chart-wrapper">
                    <canvas id="accelChart"></canvas>
                </div>
            </div>
            <div class="chart-container">
                <h4>Angular Velocity (rad/s)</h4>
                <div class="chart-wrapper">
                    <canvas id="gyroChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <h3>Live IMU Data</h3>
            
            <div id="status" class="status disconnected">
                Disconnected
            </div>
            
            <div class="metric">
                <strong>Acceleration (m/s²)</strong><br>
                X: <span id="ax">0.000</span><br>
                Y: <span id="ay">0.000</span><br>
                Z: <span id="az">0.000</span>
            </div>
            
            <div class="metric">
                <strong>Angular Velocity (rad/s)</strong><br>
                X: <span id="gx">0.000</span><br>
                Y: <span id="gy">0.000</span><br>
                Z: <span id="gz">0.000</span>
            </div>
            
            <div class="metric">
                <strong>Position (m)</strong><br>
                X: <span id="px">0.000</span><br>
                Y: <span id="py">0.000</span><br>
                Z: <span id="pz">0.000</span>
            </div>
            
            <div class="metric">
                <strong>Quaternion</strong><br>
                W: <span id="qw">1.000</span><br>
                X: <span id="qx">0.000</span><br>
                Y: <span id="qy">0.000</span><br>
                Z: <span id="qz">0.000</span>
            </div>
            
            <div class="metric">
                <strong>Timestamp</strong><br>
                <span id="timestamp">0</span>
            </div>

            <div class="metric" id="cal-metric">
                <strong>Calibration (0=Bad, 3=Good)</strong><br>
                System: <span id="cal-sys">0</span><br>
                Gyro:   <span id="cal-gyro">0</span><br>
                Accel:  <span id="cal-accel">0</span><br>
                Mag:    <span id="cal-mag">0</span>
            </div>
            
            <button onclick="connect()">Connect</button>
            <button onclick="disconnect()">Disconnect</button>
            <button onclick="resetView()">Reset View</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, imuCube, trail = [];
        let eventSource = null;
        let isConnected = false;
        
        // Chart variables
        let accelChart, gyroChart;
        const maxDataPoints = 50;
        let timeLabels = [];
        let accelData = { x: [], y: [], z: [] };
        let gyroData = { x: [], y: [], z: [] };
        
        // Smoothing filter (exponential moving average)
        const smoothingFactor = 0.3; // 0 = no smoothing, 1 = max smoothing
        let lastAccel = { x: 0, y: 0, z: 0 };
        let lastGyro = { x: 0, y: 0, z: 0 };
        
        // Initialize 3D scene
        function initScene() {
            try {
                const canvas = document.getElementById('canvas');
                if (!canvas) {
                    console.error('Canvas element not found!');
                    return;
                }
                
                if (typeof THREE === 'undefined') {
                    console.error('Three.js library not loaded!');
                    return;
                }
                
                console.log('Initializing 3D scene...');
                
                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x1a1a1a);
                
                // Camera
                camera = new THREE.PerspectiveCamera(75, canvas.width / canvas.height, 0.1, 1000);
                camera.position.set(3, 3, 3);
                camera.lookAt(0, 0, 0);
                
                // Check WebGL support
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) {
                    console.error('WebGL is not supported in this browser!');
                    canvas.style.background = '#5a2d2d';
                    canvas.style.display = 'flex';
                    canvas.style.alignItems = 'center';
                    canvas.style.justifyContent = 'center';
                    canvas.style.color = '#fff';
                    canvas.style.fontSize = '18px';
                    canvas.textContent = 'WebGL not supported. Please enable hardware acceleration in your browser settings.';
                    return;
                }
                
                // Renderer - use actual canvas display size
                try {
                    renderer = new THREE.WebGLRenderer({ 
                        canvas: canvas, 
                        antialias: true,
                        powerPreference: "high-performance"
                    });
                } catch (e) {
                    console.error('Failed to create WebGL renderer:', e);
                    canvas.style.background = '#5a2d2d';
                    canvas.style.display = 'flex';
                    canvas.style.alignItems = 'center';
                    canvas.style.justifyContent = 'center';
                    canvas.style.color = '#fff';
                    canvas.style.fontSize = '18px';
                    canvas.textContent = 'Failed to initialize WebGL renderer.';
                    return;
                }
                
                const rect = canvas.getBoundingClientRect();
                if (rect.width > 0 && rect.height > 0) {
                    renderer.setSize(rect.width, rect.height);
                    camera.aspect = rect.width / rect.height;
                    camera.updateProjectionMatrix();
                } else {
                    // Fallback to canvas dimensions
                    renderer.setSize(canvas.width, canvas.height);
                    camera.aspect = canvas.width / canvas.height;
                    camera.updateProjectionMatrix();
                }
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                console.log('Renderer initialized with size:', renderer.domElement.width, 'x', renderer.domElement.height);
                
                // Add grid
                const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
                scene.add(gridHelper);
                
                // Add axes
                const axesHelper = new THREE.AxesHelper(2);
                scene.add(axesHelper);
                
                // Create IMU cube - make it larger and more visible
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshLambertMaterial({ color: 0xff4444 });
                imuCube = new THREE.Mesh(geometry, material);
                imuCube.position.set(0, 0, 0);
                imuCube.castShadow = true;
                scene.add(imuCube);
                console.log('Red cube added to scene at position:', imuCube.position);
                
                // Add lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 5, 5);
                directionalLight.castShadow = true;
                scene.add(directionalLight);
                
                // Start render loop
                animate();
                console.log('3D scene initialized successfully');
            } catch (error) {
                console.error('Error initializing 3D scene:', error);
            }
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
        
        // Initialize charts
        function initCharts() {
            const commonOptions = {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                scales: {
                    x: {
                        ticks: { 
                            color: '#fff',
                            maxRotation: 45,
                            minRotation: 45,
                            autoSkip: true,
                            maxTicksLimit: 10
                        },
                        grid: { color: '#444' }
                    },
                    y: {
                        ticks: { 
                            color: '#fff'
                        },
                        grid: { color: '#444' }
                    }
                },
                plugins: {
                    legend: {
                        labels: { color: '#fff' }
                    }
                },
                layout: {
                    padding: {
                        bottom: 10
                    }
                }
            };
            
            // Acceleration chart with fixed Y-axis
            const accelCtx = document.getElementById('accelChart').getContext('2d');
            accelChart = new Chart(accelCtx, {
                type: 'line',
                data: {
                    labels: timeLabels,
                    datasets: [
                        {
                            label: 'X',
                            data: accelData.x,
                            borderColor: 'rgb(255, 99, 132)',
                            backgroundColor: 'rgba(255, 99, 132, 0.1)',
                            tension: 0.4,
                            pointRadius: 0,
                            borderWidth: 2
                        },
                        {
                            label: 'Y',
                            data: accelData.y,
                            borderColor: 'rgb(54, 162, 235)',
                            backgroundColor: 'rgba(54, 162, 235, 0.1)',
                            tension: 0.4,
                            pointRadius: 0,
                            borderWidth: 2
                        },
                        {
                            label: 'Z',
                            data: accelData.z,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.1)',
                            tension: 0.4,
                            pointRadius: 0,
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            min: -2,
                            max: 12,
                            ticks: {
                                color: '#fff',
                                stepSize: 2
                            }
                        }
                    }
                }
            });
            
            // Gyroscope chart with fixed Y-axis
            const gyroCtx = document.getElementById('gyroChart').getContext('2d');
            gyroChart = new Chart(gyroCtx, {
                type: 'line',
                data: {
                    labels: timeLabels,
                    datasets: [
                        {
                            label: 'X',
                            data: gyroData.x,
                            borderColor: 'rgb(255, 159, 64)',
                            backgroundColor: 'rgba(255, 159, 64, 0.1)',
                            tension: 0.4,
                            pointRadius: 0,
                            borderWidth: 2
                        },
                        {
                            label: 'Y',
                            data: gyroData.y,
                            borderColor: 'rgb(153, 102, 255)',
                            backgroundColor: 'rgba(153, 102, 255, 0.1)',
                            tension: 0.4,
                            pointRadius: 0,
                            borderWidth: 2
                        },
                        {
                            label: 'Z',
                            data: gyroData.z,
                            borderColor: 'rgb(201, 203, 207)',
                            backgroundColor: 'rgba(201, 203, 207, 0.1)',
                            tension: 0.4,
                            pointRadius: 0,
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            min: -1,
                            max: 1,
                            ticks: {
                                color: '#fff',
                                stepSize: 0.25
                            }
                        }
                    }
                }
            });
        }
        
        // Apply exponential smoothing filter
        function smoothData(newValue, lastValue, factor) {
            return lastValue + factor * (newValue - lastValue);
        }
        
        // Connect to Server-Sent Events
        function connect() {
            if (eventSource) {
                eventSource.close();
            }
            
            eventSource = new EventSource('http://localhost:8003/events');
            
            eventSource.onopen = function() {
                isConnected = true;
                updateStatus('Connected', true);
                console.log('Connected to ESP32');
            };
            
            eventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    updateDisplay(data);
                    updateIMUVisualization(data);
                    console.log('Received data:', data);
                } catch (e) {
                    console.error('Error parsing data:', e);
                }
            };
            
            eventSource.onerror = function(error) {
                console.error('SSE error:', error);
                updateStatus('Error', false);
            };
        }
        
        // Disconnect from Server-Sent Events
        function disconnect() {
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }
            isConnected = false;
            updateStatus('Disconnected', false);
        }
        
        // Update status display
        function updateStatus(message, connected) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = connected ? 'status connected' : 'status disconnected';
        }
        
        // Update data display
        function updateDisplay(data) {
            // Acceleration
            document.getElementById('ax').textContent = data.acceleration.ax.toFixed(3);
            document.getElementById('ay').textContent = data.acceleration.ay.toFixed(3);
            document.getElementById('az').textContent = data.acceleration.az.toFixed(3);
            
            // Angular velocity
            document.getElementById('gx').textContent = data.angular_velocity.gx.toFixed(3);
            document.getElementById('gy').textContent = data.angular_velocity.gy.toFixed(3);
            document.getElementById('gz').textContent = data.angular_velocity.gz.toFixed(3);
            
            // Position
            document.getElementById('px').textContent = data.position.px.toFixed(3);
            document.getElementById('py').textContent = data.position.py.toFixed(3);
            document.getElementById('pz').textContent = data.position.pz.toFixed(3);
            
            // Quaternion
            document.getElementById('qw').textContent = data.quaternion.qw.toFixed(3);
            document.getElementById('qx').textContent = data.quaternion.qx.toFixed(3);
            document.getElementById('qy').textContent = data.quaternion.qy.toFixed(3);
            document.getElementById('qz').textContent = data.quaternion.qz.toFixed(3);
            
            // Timestamp
            document.getElementById('timestamp').textContent = data.timestamp;

            // Calibration Status
            if (data.calibration) {
                let sys = data.calibration.sys;
                document.getElementById('cal-sys').textContent = sys;
                document.getElementById('cal-gyro').textContent = data.calibration.gyro;
                document.getElementById('cal-accel').textContent = data.calibration.accel;
                document.getElementById('cal-mag').textContent = data.calibration.mag;

                // Change color of status box based on system calibration
                const calBox = document.getElementById('cal-metric');
                if (sys === 3) {
                    calBox.style.backgroundColor = '#2d5a2d'; // Green
                } else if (sys > 0) {
                    calBox.style.backgroundColor = '#6e6e2b'; // Yellow/Olive
                } else {
                    calBox.style.backgroundColor = '#5a2d2d'; // Red
                }
            }
        }
        
        // Update 3D visualization
        function updateIMUVisualization(data) {
            // Update position
            imuCube.position.set(
                data.position.px,
                data.position.py,
                data.position.pz
            );
            
            // Update rotation using quaternion
            const quaternion = new THREE.Quaternion(
                data.quaternion.qx,
                data.quaternion.qy,
                data.quaternion.qz,
                data.quaternion.qw
            );
            imuCube.setRotationFromQuaternion(quaternion);
            
            // Add to trail
            trail.push({
                position: data.position,
                timestamp: data.timestamp
            });
            
            // Keep trail length manageable
            if (trail.length > 100) {
                trail.shift();
            }
            
            // Update charts
            updateCharts(data);
        }
        
        // Update charts with new data and smoothing
        function updateCharts(data) {
            const timeLabel = new Date(data.timestamp).toLocaleTimeString();
            
            // Apply smoothing to raw data
            lastAccel.x = smoothData(data.acceleration.ax, lastAccel.x, smoothingFactor);
            lastAccel.y = smoothData(data.acceleration.ay, lastAccel.y, smoothingFactor);
            lastAccel.z = smoothData(data.acceleration.az, lastAccel.z, smoothingFactor);
            
            lastGyro.x = smoothData(data.angular_velocity.gx, lastGyro.x, smoothingFactor);
            lastGyro.y = smoothData(data.angular_velocity.gy, lastGyro.y, smoothingFactor);
            lastGyro.z = smoothData(data.angular_velocity.gz, lastGyro.z, smoothingFactor);
            
            // Add smoothed data points
            timeLabels.push(timeLabel);
            accelData.x.push(lastAccel.x);
            accelData.y.push(lastAccel.y);
            accelData.z.push(lastAccel.z);
            gyroData.x.push(lastGyro.x);
            gyroData.y.push(lastGyro.y);
            gyroData.z.push(lastGyro.z);
            
            // Keep only the last maxDataPoints
            if (timeLabels.length > maxDataPoints) {
                timeLabels.shift();
                accelData.x.shift();
                accelData.y.shift();
                accelData.z.shift();
                gyroData.x.shift();
                gyroData.y.shift();
                gyroData.z.shift();
            }
            
            // Update charts
            accelChart.update('none');
            gyroChart.update('none');
        }
        
        // Reset camera view
        function resetView() {
            camera.position.set(3, 3, 3);
            camera.lookAt(0, 0, 0);
        }
        
        // Initialize when page loads
        window.addEventListener('load', function() {
            // Delay scene initialization to ensure canvas is fully rendered
            setTimeout(function() {
                initScene();
                initCharts();
            }, 100);
            // Auto-connect
            setTimeout(connect, 1000);
        });
        
        // Handle window resize
        window.addEventListener('resize', function() {
            if (!renderer || !camera) return;
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            if (rect.width > 0 && rect.height > 0) {
                camera.aspect = rect.width / rect.height;
                camera.updateProjectionMatrix();
                renderer.setSize(rect.width, rect.height);
            }
        });
    </script>
</body>
</html>
